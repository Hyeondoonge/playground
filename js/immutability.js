// [불변성]

// # 원시타입 vs 참조타입
// JS에서의 타입은 크게 원시타입, 참조타입으로 나뉜다
// 원시타입은 식별자가 가리키는 메모리에 값이 저장되고, 참조타입은 메모리 주소(참조)가 저장된다.
// 원시타입은 불변성을 가지고, 참조타입은 가지지 않아 데이터가 변경될 수 있다
// 원시타입 - number, string, boolean, null, undefined ...
// 참조타입 - Array, object, function, Date, Map, Set ...

// # 데이터의 변경
// 아래 원시타입의 변수는 값을 재할당할 때
// 실제 메모리 상에 새로운 공간을 만들어 새로운 값을 할당함으로써 불변성을 보장한다
let num = 'hello'
num = 'bye'
//        -----           -----
// num -> hello           hello
//        -----           -----
//         현정             현정
//        -----           ----- '
//                num ->   bye
//        -----           -----

// 아래 참조타입의 변수는 내부 속성을 변경할 때, 원시타입 변수와는 다르게
// 새로운 메모리 공간을 만들지 않고 기존에 저장된 데이터를 변경한다.
// 즉 새로운 공간의 생성없이 원본 값을 변경한다.
let obj = { name: '현정', children: [{ name: '수진' }, { name: '현지' }] }
obj.name = '율무'

// # 불변성을 지키는 방법
// 값을 복사하는 경우 참조타입은 '참조' 즉 메모리 주소가 복사가 되기 때문에
// 여러 식별자가 동일한 데이터를 공유하는 상황이 발생할 수 있다.
// 이러한 참조타입의 가변성으로 인한 프로그램 복잡도를 보완하기 위해 불변성을 만족하도록 관리할 수 있다.

// 1. Object.freeze (얕은 복사)
// *원본 객체*의 속성의 제거, 수정, 추가를 막는다
let ex1Obj = { name: '현정', children: [{ name: '수진' }, { name: '현지' }] }
Object.freeze(ex1Obj)
ex1Obj.name = '예상치 못한 접근'
console.log(ex1Obj)

// 얕은 freeze로 인한 문제점: 깊은 데이터 변경 가능성
ex1Obj.children[0].name = '예상치 못한 접근' // { name: '율무', children: [ { name: '예상치 못한 접근' }, { name: '현지' } ] }
console.log(ex1Obj)

// 2. Object.assign (얕은 복사)
// 원본 객체에 출처 객체의 속성들을 복사하여 붙여넣음
// 3. spread 연산자 (얕은 복사)
// 객체의 속성들을 복사하여 붙여넣음

// # 얕은 복사의 보완 방법: 깊은 복사
// 1. 재귀적 구현 (깊은 복사)
// 2. StructuredClone (깊은 복사)
// 3. JSON stringify & parse (깊은 복사)
